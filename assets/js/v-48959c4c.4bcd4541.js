"use strict";(self.webpackChunkblog_demo=self.webpackChunkblog_demo||[]).push([[984],{8086:(a,e,t)=>{t.r(e),t.d(e,{data:()=>h});const h={key:"v-48959c4c",path:"/base/Interaction.html",title:"前后端交互详细步骤",lang:"zh-CN",frontmatter:{date:"2022/2/24 8:46",title:"前后端交互详细步骤"},excerpt:"",headers:[{level:2,title:"前后端交互",slug:"前后端交互",children:[]}],git:{updatedTime:null,contributors:[]}}},6887:(a,e,t)=>{t.r(e),t.d(e,{default:()=>r});const h=(0,t(6252).uE)('<h2 id="前后端交互" tabindex="-1"><a class="header-anchor" href="#前后端交互" aria-hidden="true">#</a> 前后端交互</h2><p>浏览器输入域名到页面显示完整的流程</p><h5 id="_1-浏览器输入地址比如http-www-baidu-com-根据域名和端口号通过dns解析成ip地址" tabindex="-1"><a class="header-anchor" href="#_1-浏览器输入地址比如http-www-baidu-com-根据域名和端口号通过dns解析成ip地址" aria-hidden="true">#</a> 1.浏览器输入地址比如http://www.baidu.com，根据域名和端口号通过DNS解析成IP地址</h5><h5 id="_2-根据ip地址以及端口号找到对应的服务器" tabindex="-1"><a class="header-anchor" href="#_2-根据ip地址以及端口号找到对应的服务器" aria-hidden="true">#</a> 2.根据IP地址以及端口号找到对应的服务器</h5><p><a href="http://www.imooc.com/wiki/httplesson/socketprotocol.html">(http协议中的tcp协议) 协议三次握手和四次挥手</a> http的默认端口号80 https默认端口号443 ftp默认端口21 mysql默认端口号3306</p><h5 id="_3-服务器接收到来自前端的请求-分配到对应路由" tabindex="-1"><a class="header-anchor" href="#_3-服务器接收到来自前端的请求-分配到对应路由" aria-hidden="true">#</a> 3.服务器接收到来自前端的请求，分配到对应路由‘/’</h5><h5 id="_4-在路由里取到对应的文件。例如-index-html" tabindex="-1"><a class="header-anchor" href="#_4-在路由里取到对应的文件。例如-index-html" aria-hidden="true">#</a> 4.在路由里取到对应的文件。例如 index.html</h5><p><strong>（1）直接将index.html文件返回</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>\ta.有可能首页没什么数据，就是个静态页\n\tb.也有可能页面并不完整，但是后端不渲染，先返回给前端，后期前端通过ajax重新渲染\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>（2）先取出index.html，然后再从数据库里拿到数据，根据数据完成页面模板替换，数据填充，得到完整的页面html字符串，再返回给前端（后端渲染）</strong> 注：1.前端渲染减轻服务器压力，但是不利于搜索引擎优化** 2.后端渲染服务器压力较大，但是利于搜索引擎优化</p><h5 id="_5-浏览器拿到index-html了-就开始渲染" tabindex="-1"><a class="header-anchor" href="#_5-浏览器拿到index-html了-就开始渲染" aria-hidden="true">#</a> 5.浏览器拿到index.html了，就开始渲染</h5><h5 id="_6-如果遇到了link标签-继续向对应服务器发送一个http请求-请求css文件-渲染样式" tabindex="-1"><a class="header-anchor" href="#_6-如果遇到了link标签-继续向对应服务器发送一个http请求-请求css文件-渲染样式" aria-hidden="true">#</a> 6.如果遇到了link标签，继续向对应服务器发送一个http请求，请求css文件，渲染样式</h5><h5 id="_7-如果遇到了script标签-继续向对应服务器发送一个http请求-请求js文件-执行逻辑" tabindex="-1"><a class="header-anchor" href="#_7-如果遇到了script标签-继续向对应服务器发送一个http请求-请求js文件-执行逻辑" aria-hidden="true">#</a> 7.如果遇到了script标签，继续向对应服务器发送一个http请求，请求js文件，执行逻辑</h5><h5 id="_8-如果js里有ajax请求-就会请求对应服务器" tabindex="-1"><a class="header-anchor" href="#_8-如果js里有ajax请求-就会请求对应服务器" aria-hidden="true">#</a> 8.如果js里有ajax请求，就会请求对应服务器</h5><p>（1）异步请求，再回调里才能拿到结果，或者可以使用promise （2）状态码 （3）数据格式，一般来讲都是json</p><h5 id="_9-服务器进入相应的路由-在这个路由代码里就会去查找数据库-得到json格式的数据-再返回给前端" tabindex="-1"><a class="header-anchor" href="#_9-服务器进入相应的路由-在这个路由代码里就会去查找数据库-得到json格式的数据-再返回给前端" aria-hidden="true">#</a> 9.服务器进入相应的路由，在这个路由代码里就会去查找数据库，得到json格式的数据，再返回给前端</h5><h5 id="_10-前端拿到json数据以后更新页面的部分内容" tabindex="-1"><a class="header-anchor" href="#_10-前端拿到json数据以后更新页面的部分内容" aria-hidden="true">#</a> 10.前端拿到json数据以后更新页面的部分内容</h5>',17),n={},r=(0,t(3744).Z)(n,[["render",function(a,e){return h}]])}}]);